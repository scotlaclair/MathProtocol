name: AI Review Orchestrator (Label Based)

on:
  pull_request_target:
    types: [opened, labeled, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  orchestrate:
    name: Orchestrate AI Reviews
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Manage Agent State Machine
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const labels = pr.labels.map(l => l.name);
            
            // Define the Agent State Machine
            const STATE = {
              INIT: 'status: needs-triage',
              GEMINI: 'status: gemini-review',
              COPILOT: 'status: copilot-review',
              CODEX: 'status: codex-security',
              APPROVED: 'status: ai-approved'
            };
            
            const ALL_STATES = Object.values(STATE);
            
            core.info(`PR #${pr.number} - Event: ${context.payload.action}`);
            core.info(`Current labels: ${labels.join(', ')}`);
            
            // Helper: Remove all state labels except the specified one
            async function setOnlyState(newState) {
              for (const state of ALL_STATES) {
                if (state !== newState && labels.includes(state)) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      name: state
                    });
                    core.info(`Removed label: ${state}`);
                  } catch (error) {
                    core.warning(`Failed to remove label ${state}: ${error.message}`);
                  }
                }
              }
              
              if (!labels.includes(newState)) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [newState]
                });
                core.info(`Added label: ${newState}`);
              }
            }
            
            // Helper: Post review summary comment
            async function postReviewSummary(agent, message) {
              const marker = `<!-- AI_REVIEW_${agent}_STATUS -->`;
              const timestamp = new Date().toISOString();
              const body = `${marker}\n## ðŸ¤– ${agent} Review\n\n${message}\n\n---\n*Updated: ${timestamp}*`;
              
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });
              
              const existing = comments.data.find(c => 
                c.user.login === 'github-actions[bot]' && c.body.includes(marker)
              );
              
              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: body
                });
              }
            }
            
            // 1. Initial State (New PR)
            if (context.payload.action === 'opened') {
              await setOnlyState(STATE.GEMINI);
              await postReviewSummary('Gemini', 'ðŸš€ **Gemini Code Assist** architectural review has been triggered.\n\nWaiting for Gemini to analyze the code...');
              core.info('New PR opened - Set to Gemini review state');
              return;
            }
            
            // 2. State Machine Logic
            if (context.payload.action === 'labeled' || context.payload.action === 'synchronize') {
              
              // GEMINI REVIEW STATE
              if (labels.includes(STATE.GEMINI)) {
                core.info('Gemini review state active');
                await postReviewSummary('Gemini', 'ðŸ” **Gemini Code Assist** is reviewing architectural design and patterns.\n\n**Next Step:** After Gemini completes review, manually remove `status: gemini-review` label and add `status: copilot-review` label to proceed.');
                
                // Note: Actual Gemini API call would go here
                // For now, this is a placeholder for manual progression
              }
              
              // COPILOT REVIEW STATE
              if (labels.includes(STATE.COPILOT)) {
                core.info('Copilot review state active');
                await postReviewSummary('Copilot', 'ðŸ“ **GitHub Copilot** is reviewing code quality, style, and best practices.\n\n**Next Step:** After Copilot completes review, manually remove `status: copilot-review` label and add `status: codex-security` label to proceed.');
                
                // Note: Copilot review integration would go here
              }
              
              // CODEX SECURITY STATE
              if (labels.includes(STATE.CODEX)) {
                core.info('Codex security review state active');
                await postReviewSummary('Codex', 'ðŸ”’ **Codex** is performing deep security analysis and vulnerability scanning.\n\n**Next Step:** After Codex completes review, manually remove `status: codex-security` label and add `status: ai-approved` label to complete AI review.');
                
                // Note: Codex security scan would go here
              }
              
              // APPROVED STATE
              if (labels.includes(STATE.APPROVED)) {
                core.info('All AI reviews complete - PR approved');
                await postReviewSummary('Final', 'âœ… **All AI Reviews Complete!**\n\nThe PR has passed:\n- âœ… Gemini architectural review\n- âœ… Copilot code quality review\n- âœ… Codex security analysis\n\nðŸŽ‰ Ready for human review and merge!');
              }
            }
            
            // Create workflow summary
            const currentState = ALL_STATES.find(s => labels.includes(s)) || 'None';
            await core.summary
              .addHeading('AI Review State Machine Status')
              .addTable([
                [
                  { data: 'State', header: true },
                  { data: 'Label', header: true },
                  { data: 'Active', header: true }
                ],
                ['Initial Triage', STATE.INIT, labels.includes(STATE.INIT) ? 'âœ…' : 'â¬œ'],
                ['Gemini Review', STATE.GEMINI, labels.includes(STATE.GEMINI) ? 'âœ…' : 'â¬œ'],
                ['Copilot Review', STATE.COPILOT, labels.includes(STATE.COPILOT) ? 'âœ…' : 'â¬œ'],
                ['Codex Security', STATE.CODEX, labels.includes(STATE.CODEX) ? 'âœ…' : 'â¬œ'],
                ['AI Approved', STATE.APPROVED, labels.includes(STATE.APPROVED) ? 'âœ…' : 'â¬œ']
              ])
              .addRaw(`\n**Current State:** ${currentState}`)
              .addRaw(`\n**PR Number:** ${pr.number}`)
              .addRaw(`\n**Event:** ${context.payload.action}`)
              .write();
            
            core.info('State machine orchestration complete');
            core.setOutput('current_state', currentState);
            core.setOutput('pr_number', pr.number);
